# üìÑ Gestion d‚Äôune erreur de migration Prisma en production (cas `P3009`)

## 1. Contexte

Nous avons ajout√© une colonne `sshPort` au mod√®le `Server` dans Prisma, avec la contrainte `NOT NULL` et une valeur par d√©faut `22`.
Une migration `20250919081913_server_ansible_tweaks` a √©t√© g√©n√©r√©e et d√©ploy√©e en production via Prisma Migrate.

## 2. Sympt√¥me

En production, le backend a crash√© au d√©marrage :

* Les logs Prisma affichaient l‚Äôerreur **P3009** ‚Üí *"The failed migration(s) need to be resolved before Prisma can continue."*
* Le healthcheck `/health` √©chouait, car l‚ÄôAPI ne d√©marrait pas (bloqu√©e par `prisma migrate deploy`).

Dans la table `_prisma_migrations`, l‚Äôentr√©e pour `20250919081913_server_ansible_tweaks` avait :

* `finished_at = NULL`
* `rolled_back_at` renseign√©
  ‚û°Ô∏è Migration consid√©r√©e comme √©chou√©e.

## 3. Cause profonde

Prisma bloque l‚Äôapplication de nouvelles migrations tant qu‚Äôune migration √©chou√©e n‚Äôest pas ‚Äúr√©concili√©e‚Äù.
Cela arrive typiquement quand :

* On ajoute une colonne `NOT NULL` sans √©tape interm√©diaire pour remplir les anciennes lignes.
* Le SQL g√©n√©r√© par Prisma √©choue (ex : MySQL refuse d‚Äôajouter une colonne non nulle sans valeur par d√©faut applicable).
* La migration a √©t√© annul√©e (rolled back), mais Prisma garde l‚Äô√©tat ‚Äúbloqu√©‚Äù dans `_prisma_migrations`.

Dans notre cas :

* La colonne `sshPort` existait d√©j√† en base (avec d√©faut `22`), mais Prisma n‚Äôavait jamais marqu√© la migration comme termin√©e.
  ‚û°Ô∏è Prisma √©tait ‚Äúd√©synchronis√©‚Äù par rapport √† la r√©alit√© de la base.

## 4. Solution appliqu√©e

### √âtape 1 ‚Äî V√©rifier l‚Äô√©tat r√©el en base

```sql
SHOW COLUMNS FROM Server LIKE "sshPort";
SELECT COUNT(*) AS nulls FROM Server WHERE sshPort IS NULL;
```

R√©sultat :

* Colonne `sshPort` pr√©sente.
* 0 valeurs NULL.
  ‚û°Ô∏è La contrainte `NOT NULL` √©tait effectivement respect√©e.

### √âtape 2 ‚Äî R√©concilier Prisma

On a marqu√© manuellement la migration comme **appliqu√©e** :

```bash
npx prisma migrate resolve --applied "20250919081913_server_ansible_tweaks"
```

### √âtape 3 ‚Äî Red√©marrage

* Red√©marrage du conteneur backend.
* V√©rification du healthcheck `/health` ‚Üí **OK**.
  ‚û°Ô∏è API de nouveau fonctionnelle.

## 5. Objectif et ce que √ßa r√©sout

* Synchroniser l‚Äôhistorique des migrations Prisma avec l‚Äô√©tat r√©el de la base.
* D√©bloquer `prisma migrate deploy`, qui refusait d‚Äôappliquer les migrations suivantes.
* √âviter que Prisma reste bloqu√© √† chaque d√©ploiement.

## 6. Comment √©viter √† l‚Äôavenir

1. **Toujours √©viter les colonnes `NOT NULL` directes sur des tables d√©j√† peupl√©es.**
   Utiliser la strat√©gie SQL *safe* :

    * Ajouter la colonne en `NULL`.
    * Backfiller avec une valeur par d√©faut.
    * Passer ensuite en `NOT NULL`.
      ‚Üí Cela se fait en √©ditant manuellement le `migration.sql` g√©n√©r√© par Prisma.

2. **Toujours tester la migration localement** (avec des donn√©es r√©alistes) avant d√©ploiement en prod.

3. **Si l‚Äôerreur arrive malgr√© tout :**

    * V√©rifier dans `_prisma_migrations` l‚Äô√©tat (`finished_at` / `rolled_back_at`).
    * V√©rifier en base si la colonne existe et si elle respecte la contrainte.
    * Selon le cas :

        * Colonne OK + pas de NULL ‚Üí `migrate resolve --applied`.
        * Colonne existe mais avec NULL ‚Üí backfill + `ALTER TABLE` + `migrate resolve`.
        * Colonne absente ‚Üí appliquer le SQL safe manuellement + `migrate resolve`.

4. **Ne jamais supprimer une migration √©chou√©e localement** en pensant r√©soudre le probl√®me.
   Prisma regarde l‚Äôhistorique dans la **base**, pas seulement les fichiers.

## 7. Checklist rapide pour la prochaine fois

* [ ] `SHOW COLUMNS` pour v√©rifier si le changement existe.
* [ ] `SELECT COUNT(*)` pour d√©tecter les NULL/violations.
* [ ] Si la colonne est conforme ‚Üí `migrate resolve --applied`.
* [ ] Sinon ‚Üí corriger en SQL, backfill, puis `migrate resolve`.
* [ ] Red√©marrer l‚ÄôAPI et tester `/health`.


## Solution choisie

√âtant donn√© que l‚Äôerreur est intervenue en tout d√©but de projet, sans donn√©es importantes en base ni historique critique de migrations, la solution la plus simple et propre a √©t√© de **r√©initialiser enti√®rement l‚Äôhistorique de migrations**.

### √âtapes r√©alis√©es

1. **Suppression des anciennes migrations** dans le dossier `prisma/migrations`.
2. **Reset de la base de donn√©es** avec Prisma pour repartir sur une base vide :

   ```bash
   npx prisma migrate reset
   ```

   Prisma impose cette √©tape pour √©viter toute suppression accidentelle.
3. **G√©n√©ration d‚Äôune migration unique et propre** correspondant au sch√©ma actuel :

   ```bash
   npx prisma migrate dev --name init
   ```
4. **G√©n√©ration du client Prisma** puis injection des donn√©es de test avec le script de seed :

   ```bash
   npx prisma generate
   npm run seed
   ```
5. **V√©rification locale** : modification du `.env` pour pointer vers ma base locale (`DATABASE_URL=...`), test de la migration + seed.
6. **Retour sur la prod** : r√©tablissement de l‚Äô`env.DATABASE_URL` en URL de prod, puis arr√™t et suppression des conteneurs ainsi que des volumes associ√©s, afin de repartir sur une base vierge.
7. **D√©ploiement** : relance du workflow avec cette migration unique ‚Üí tout s‚Äôest appliqu√© sans probl√®me.

### Analyse de la cause

Le probl√®me initial provenait du fait qu‚Äôun **champ d√©fini comme NOT NULL** avait √©t√© ajout√© dans une migration alors que des donn√©es existaient d√©j√† dans la base.
‚û°Ô∏è MySQL bloque ce type d‚Äôop√©ration car il ne peut pas r√©tro-remplir automatiquement une valeur sur les enregistrements existants.
‚û°Ô∏è Prisma a donc marqu√© la migration comme √©chou√©e, bloquant tout l‚Äôhistorique par s√©curit√©.

### D√©cision

* En phase de prototypage, **r√©initialiser l‚Äôhistorique** et repartir sur une migration unique est la solution la plus simple et la plus fiable.
* En production r√©elle (avec des donn√©es √† conserver), il faudra au contraire pr√©voir des migrations plus progressives (ajout de champ en nullable, backfill, puis passage en NOT NULL) ou corriger via SQL + `prisma migrate resolve`.

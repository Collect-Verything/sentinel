# üìÑ Gestion d‚Äôune erreur de migration Prisma en production (cas `P3009`)

## 1. Contexte

Nous avons ajout√© une colonne `sshPort` au mod√®le `Server` dans Prisma, avec la contrainte `NOT NULL` et une valeur par d√©faut `22`.
Une migration `20250919081913_server_ansible_tweaks` a √©t√© g√©n√©r√©e et d√©ploy√©e en production via Prisma Migrate.

## 2. Sympt√¥me

En production, le backend a crash√© au d√©marrage :

* Les logs Prisma affichaient l‚Äôerreur **P3009** ‚Üí *"The failed migration(s) need to be resolved before Prisma can continue."*
* Le healthcheck `/health` √©chouait, car l‚ÄôAPI ne d√©marrait pas (bloqu√©e par `prisma migrate deploy`).

Dans la table `_prisma_migrations`, l‚Äôentr√©e pour `20250919081913_server_ansible_tweaks` avait :

* `finished_at = NULL`
* `rolled_back_at` renseign√©
  ‚û°Ô∏è Migration consid√©r√©e comme √©chou√©e.

## 3. Cause profonde

Prisma bloque l‚Äôapplication de nouvelles migrations tant qu‚Äôune migration √©chou√©e n‚Äôest pas ‚Äúr√©concili√©e‚Äù.
Cela arrive typiquement quand :

* On ajoute une colonne `NOT NULL` sans √©tape interm√©diaire pour remplir les anciennes lignes.
* Le SQL g√©n√©r√© par Prisma √©choue (ex : MySQL refuse d‚Äôajouter une colonne non nulle sans valeur par d√©faut applicable).
* La migration a √©t√© annul√©e (rolled back), mais Prisma garde l‚Äô√©tat ‚Äúbloqu√©‚Äù dans `_prisma_migrations`.

Dans notre cas :

* La colonne `sshPort` existait d√©j√† en base (avec d√©faut `22`), mais Prisma n‚Äôavait jamais marqu√© la migration comme termin√©e.
  ‚û°Ô∏è Prisma √©tait ‚Äúd√©synchronis√©‚Äù par rapport √† la r√©alit√© de la base.

## 4. Solution appliqu√©e

### √âtape 1 ‚Äî V√©rifier l‚Äô√©tat r√©el en base

```sql
SHOW COLUMNS FROM Server LIKE "sshPort";
SELECT COUNT(*) AS nulls FROM Server WHERE sshPort IS NULL;
```

R√©sultat :

* Colonne `sshPort` pr√©sente.
* 0 valeurs NULL.
  ‚û°Ô∏è La contrainte `NOT NULL` √©tait effectivement respect√©e.

### √âtape 2 ‚Äî R√©concilier Prisma

On a marqu√© manuellement la migration comme **appliqu√©e** :

```bash
npx prisma migrate resolve --applied "20250919081913_server_ansible_tweaks"
```

### √âtape 3 ‚Äî Red√©marrage

* Red√©marrage du conteneur backend.
* V√©rification du healthcheck `/health` ‚Üí **OK**.
  ‚û°Ô∏è API de nouveau fonctionnelle.

## 5. Objectif et ce que √ßa r√©sout

* Synchroniser l‚Äôhistorique des migrations Prisma avec l‚Äô√©tat r√©el de la base.
* D√©bloquer `prisma migrate deploy`, qui refusait d‚Äôappliquer les migrations suivantes.
* √âviter que Prisma reste bloqu√© √† chaque d√©ploiement.

## 6. Comment √©viter √† l‚Äôavenir

1. **Toujours √©viter les colonnes `NOT NULL` directes sur des tables d√©j√† peupl√©es.**
   Utiliser la strat√©gie SQL *safe* :

    * Ajouter la colonne en `NULL`.
    * Backfiller avec une valeur par d√©faut.
    * Passer ensuite en `NOT NULL`.
      ‚Üí Cela se fait en √©ditant manuellement le `migration.sql` g√©n√©r√© par Prisma.

2. **Toujours tester la migration localement** (avec des donn√©es r√©alistes) avant d√©ploiement en prod.

3. **Si l‚Äôerreur arrive malgr√© tout :**

    * V√©rifier dans `_prisma_migrations` l‚Äô√©tat (`finished_at` / `rolled_back_at`).
    * V√©rifier en base si la colonne existe et si elle respecte la contrainte.
    * Selon le cas :

        * Colonne OK + pas de NULL ‚Üí `migrate resolve --applied`.
        * Colonne existe mais avec NULL ‚Üí backfill + `ALTER TABLE` + `migrate resolve`.
        * Colonne absente ‚Üí appliquer le SQL safe manuellement + `migrate resolve`.

4. **Ne jamais supprimer une migration √©chou√©e localement** en pensant r√©soudre le probl√®me.
   Prisma regarde l‚Äôhistorique dans la **base**, pas seulement les fichiers.

## 7. Checklist rapide pour la prochaine fois

* [ ] `SHOW COLUMNS` pour v√©rifier si le changement existe.
* [ ] `SELECT COUNT(*)` pour d√©tecter les NULL/violations.
* [ ] Si la colonne est conforme ‚Üí `migrate resolve --applied`.
* [ ] Sinon ‚Üí corriger en SQL, backfill, puis `migrate resolve`.
* [ ] Red√©marrer l‚ÄôAPI et tester `/health`.

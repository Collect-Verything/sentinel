# 1) Pourquoi deux √©tapes : **build stage** vs **runtime stage**

C‚Äôest un **multi-stage build**. On utilise une premi√®re image ‚Äúatelier‚Äù pour **compiler** l‚Äôapp (installer deps, g√©n√©rer Prisma, transpiler NestJS ‚Üí `dist/`), puis on copie **uniquement** ce qui est n√©cessaire dans une image finale, plus propre.

**Objectifs :**

* **Taille** plus petite : la runtime n‚Äôembarque pas le cache npm, `tsc`, etc.
* **S√©curit√©** : on n‚Äôexpose pas tous les outils de build en prod.
* **Reproductibilit√©** : on fige ce qui est construit et on l‚Äôex√©cute tel quel.

Concr√®tement :

* **Build stage** ‚Üí `npm ci`, `npx prisma generate`, `npm run build`.
* **Runtime stage** ‚Üí on **copie** `node_modules/`, `dist/`, `prisma/` puis on **ex√©cute** (migrate/seed/start).

---

# 2) Pourquoi installer **OpenSSL / libssl** ? Et pourquoi Prisma r√¢le sans √ßa ?

Prisma utilise des **engines natifs** (binaries compil√©s) qui dialoguent avec la DB.
Ces engines se lient aux biblioth√®ques **OpenSSL** de l‚ÄôOS.
Sur Debian 12 (bookworm), c‚Äôest **OpenSSL 3** ‚Üí paquet **`libssl3`**.

Sans libssl appropri√©, Prisma ne peut pas charger le moteur ‚Üí warning/erreur du type :

> ‚ÄúPrisma failed to detect libssl ‚Ä¶ defaulting to openssl-1.1.x / engine not found ‚Ä¶‚Äù

**En r√©sum√© :**

* **√Ä l‚Äôex√©cution** (runtime), Prisma **doit** trouver OpenSSL (libssl) pour :

    * `prisma migrate deploy`
    * `prisma db seed`
    * l‚Äô**ORM** qui tourne pendant l‚ÄôAPI (queries √† la DB)
* **Au build** (facultatif mais utile), `prisma generate` peut aussi ex√©cuter des binaires/validations ; installer `openssl`/`ca-certificates` √©vite des surprises et garantit que le client g√©n√©r√© est coh√©rent.

üëâ D‚Äôo√π **l‚Äôinstallation dans les deux √©tapes** :

* **Build stage** : `openssl` + `ca-certificates` ‚Üí pour que `prisma generate` marche proprement.
* **Runtime stage** : `openssl` + `libssl3` + `ca-certificates` ‚Üí pour que **migrate/seed** et l‚ÄôORM au runtime fonctionnent.

> Nota : `ca-certificates` √©vite des erreurs TLS (utile si tu passes un jour par une DB distante chiffr√©e, services externes, etc.).

---

# 3) D√©tails de chaque instruction du Dockerfile

## Build stage

```dockerfile
FROM node:20-bookworm-slim AS build
WORKDIR /app
RUN apt-get update && apt-get install -y --no-install-recommends openssl ca-certificates \
  && rm -rf /var/lib/apt/lists/*
COPY package*.json ./
RUN npm ci
COPY . .
RUN npx prisma generate
RUN npm run build
```

* `openssl ca-certificates` : voir plus haut (prisma generate).
* `npm ci` : installe **exactement** les versions de `package-lock.json` (reproductible).
* `npx prisma generate` : g√©n√®re le **client Prisma** (prend en compte `binaryTargets`).
* `npm run build` : transpile NestJS/TS ‚Üí **`dist/`**.

## Runtime stage

```dockerfile
FROM node:20-bookworm-slim
WORKDIR /app
ENV NODE_ENV=production
RUN apt-get update && apt-get install -y --no-install-recommends openssl ca-certificates libssl3 \
  && rm -rf /var/lib/apt/lists/*
COPY --from=build /app/node_modules ./node_modules
COPY --from=build /app/dist ./dist
COPY --from=build /app/prisma ./prisma
COPY package*.json ./
EXPOSE 3001
```

* `libssl3` : **crucial** pour Prisma sur Debian 12.
* On **copie** ce qu‚Äôon a produit (deps, build, sch√©mas/migrations).
* `EXPOSE 3001` : l‚ÄôAPI √©coute sur 3001.

---

# 4) D√©tail du **CMD** (ce qui se passe au d√©marrage du conteneur)

```dockerfile
CMD sh -lc '\
  echo "[migrate] prisma migrate deploy (retry)"; \
  for i in $(seq 1 60); do npx prisma migrate deploy && break || (echo "retry $i/60" && sleep 2); done; \
  echo "[seed] prisma db seed:prod (non-fatal)"; \
  npm run seed:prod || true; \
  echo "[start] node dist/src/main.js"; \
  node dist/src/main.js \
'
```

**√âtape par √©tape :**

1. **Migrations (idempotent, avec retries)**

    * `prisma migrate deploy` applique **uniquement** les migrations **d√©j√† g√©n√©r√©es**.
    * La boucle `for` r√©essaye jusqu‚Äô√† 60 fois avec 2s d‚Äôintervalle ‚Üí utile si la DB n‚Äôest pas tout de suite dispo (m√™me si le conteneur est d√©j√† up gr√¢ce √† Docker).
    * Si √ßa r√©ussit, on `break`; sinon on retente.

2. **Seed (optionnel, non fatal)**

    * `npm run seed:prod || true` : ex√©cute ton seed (ex. via `tsx prisma/seed.ts`).
    * `|| true` √©vite d‚Äôarr√™ter le conteneur si le seed √©choue (tu peux le rendre fatal si tu pr√©f√®res).

3. **D√©marrage de l‚ÄôAPI**

    * `node dist/src/main.js` : lance NestJS construit √† l‚Äô√©tape build.
    * (Si ta build √©met `dist/main.js` sans `src/`, adapte le chemin.)

**Pourquoi cette s√©quence au runtime ?**

* Pour **garantir** que le sch√©ma DB est √† jour **au moment pr√©cis** o√π l‚ÄôAPI d√©marre (et sur chaque d√©ploiement), sans d√©pendre d‚Äôun job externe.
* Le seed en prod est discutable (souvent on le coupe), mais pour ton cas de test initial, c‚Äôest pratique et robuste (non fatal).

---

## TL;DR

* **Deux √©tapes** = on **construit** proprement (generate + build) puis on **ex√©cute** dans une image l√©g√®re et s√ªre.
* **OpenSSL/libssl** sont **indispensables** √† Prisma (engines natifs) : on les met **au build** (pour `prisma generate`) et **au runtime** (pour `migrate/seed` + ORM).
* Le **CMD** ex√©cute : **migrate (avec retry)** ‚Üí **seed (non fatal)** ‚Üí **start API**.

# üöÄ CI/CD Backend ‚Äì `deploy-back.yaml` (explication compl√®te)

Ce document d√©taille le fonctionnement du workflow GitHub Actions pour le d√©ploiement du backend, √©tape par √©tape.
Chaque section du fichier YAML est expliqu√©e avec son r√¥le, la raison du choix, les probl√®mes rencontr√©s et la justification finale.

---

## 1) En-t√™te du workflow

```yaml
name: Back CI/CD

on:
  push:
    branches: [ main ]
    paths:
      - "back/**"
      - ".github/workflows/deploy-back.yml"
  workflow_dispatch: {}
```

**Ce que √ßa fait**

* Se d√©clenche √† chaque push sur `main` **uniquement si** des fichiers dans `back/**` ou le fichier du workflow ont chang√©.
* `workflow_dispatch` permet de d√©clencher manuellement le workflow depuis l‚Äôonglet Actions.

**Pourquoi**

* √âvite de reconstruire/d√©ployer quand seul le front ou d‚Äôautres fichiers sont modifi√©s.
* Permet un red√©ploiement manuel utile en cas de hotfix.

**Probl√®mes rencontr√©s**

* L‚Äôextension du fichier doit correspondre (`.yml` vs `.yaml`) sinon le filtre `paths` ne r√©agit pas.

---

## 2) Gestion de concurrence

```yaml
concurrency:
  group: back-deploy
  cancel-in-progress: true
```

**Ce que √ßa fait**

* Garantit qu‚Äôun seul d√©ploiement backend peut tourner √† la fois.
* Si un nouveau est lanc√©, il annule celui en cours.

**Pourquoi**

* √âvite deux d√©ploiements concurrents qui pourraient entrer en conflit et casser l‚Äôapp.

---

## 3) Variables globales

```yaml
env:
  IMAGE_NAME: sentinel-back
  APP_NAME: sentinel-back
  EXPOSED_PORT: "3001"
  INTERNAL_PORT: "3001"
  NETWORK_NAME: sentinel-back
```

**Ce que √ßa fait**

* D√©finit des constantes r√©utilis√©es plus bas (nom de l‚Äôimage, conteneur, r√©seau, ports).

**Pourquoi**

* Plus facile √† maintenir : si on change un port ou un nom, un seul endroit √† modifier.

---

## 4) D√©finition du job

```yaml
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
```

**Ce que √ßa fait**

* Ex√©cute le job sur une VM GitHub Linux (`ubuntu-latest`).

**Pourquoi**

* Fournit un environnement Docker fiable pour construire nos images.

---

## 5) Checkout & Buildx

```yaml
steps:
  - name: Checkout
    uses: actions/checkout@v4

  - name: Set up Docker Buildx
    uses: docker/setup-buildx-action@v3
```

**Ce que √ßa fait**

* R√©cup√®re le code du d√©p√¥t.
* Active Buildx (outil avanc√© de build Docker).

**Pourquoi**

* Buildx permet d‚Äôutiliser un cache efficace et supporte le multi-architecture.

---

## 6) Connexion √† Docker Hub

```yaml
  - name: Login to Docker Hub
    uses: docker/login-action@v3
    with:
      username: ${{ secrets.DOCKERHUB_USERNAME }}
      password: ${{ secrets.DOCKERHUB_TOKEN }}
```

**Ce que √ßa fait**

* Authentifie le runner GitHub aupr√®s de Docker Hub.

**Pourquoi**

* N√©cessaire pour pousser les images.

**S√©curit√©**

* Utilisation de **secrets GitHub**, jamais de credentials en clair.

---

## 7) G√©n√©ration des m√©tadonn√©es (tags)

```yaml
  - name: Docker meta
    id: meta
    uses: docker/metadata-action@v5
    with:
      images: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}
      tags: |
        type=raw,value=latest
        type=raw,value=sha-${{ github.sha }}
        type=raw,value=v${{ github.run_number }}
```

**Ce que √ßa fait**

* Cr√©e plusieurs tags :

    * `latest` : pour usage rapide
    * `sha-<commit>` : reproductible, exact commit
    * `v<run_number>` : lisible pour l‚Äôhistorique

**Pourquoi**

* `latest` = pratique
* SHA = garantit de d√©ployer exactement ce qu‚Äôon a construit
* Num√©ro de run = utile pour suivre les builds

---

## 8) Build & push de l‚Äôimage backend

```yaml
  - name: Build and push
    uses: docker/build-push-action@v6
    with:
      context: ./back
      file: ./back/Dockerfile
      push: true
      tags: ${{ steps.meta.outputs.tags }}
      labels: ${{ steps.meta.outputs.labels }}
      cache-from: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
      cache-to: type=inline
      no-cache: true
```

**Ce que √ßa fait**

* Construit l‚Äôimage backend (multi-stage Dockerfile).
* La pousse vers Docker Hub avec tous les tags.

**Pourquoi**

* Centraliser les builds dans CI/CD.
* Le serveur ne fait que **puller**.

**Probl√®mes rencontr√©s**

* **Prisma / OpenSSL** : on a d√ª installer `libssl3` dans l‚Äôimage pour √©viter des erreurs.
* **Seed TS** : n√©cessit√© d‚Äôajouter `tsx` en d√©pendance pour ex√©cuter un seed `.ts` en prod.
* **Cache obsol√®te** : parfois l‚Äôimage ne prenait pas en compte `package.json` ‚Üí `no-cache: true` pour forcer un rebuild.

---

## 9) D√©ploiement sur le serveur (SSH)

```yaml
  - name: Deploy to server
    uses: appleboy/ssh-action@v1.0.0
    with:
      host: ${{ vars.SSH_HOST }}
      username: ${{ vars.SSH_USER }}
      password: ${{ secrets.SSH_PASSWORD }}
      port: 22
      script: |
        set -euo pipefail
```

**Ce que √ßa fait**

* Se connecte en SSH et ex√©cute le script de d√©ploiement.

**Pourquoi**

* Automatisation compl√®te, plus besoin de lancer des commandes manuelles.

**S√©curit√©**

* Pourra √©voluer vers des cl√©s SSH plut√¥t qu‚Äôun mot de passe.

---

## 10) Variables c√¥t√© serveur

```bash
IMAGE="‚Ä¶"
APP="‚Ä¶"
NET="‚Ä¶"
EXTERNAL_PORT="‚Ä¶"
INTERNAL_PORT="‚Ä¶"

MYSQL_ROOT_PASSWORD="‚Ä¶"
MYSQL_DATABASE="‚Ä¶"
MYSQL_USER="‚Ä¶"
MYSQL_PASSWORD="‚Ä¶"
```

**Ce que √ßa fait**

* Pr√©pare toutes les variables n√©cessaires au script (image, conteneur, r√©seau, DB).

**Pourquoi**

* Lisibilit√© + aucune valeur sensible hardcod√©e.

---

## 11) Pull & r√©seau

```bash
docker pull "$IMAGE"
docker network create "$NET" >/dev/null 2>&1 || true
```

**Ce que √ßa fait**

* T√©l√©charge la nouvelle image.
* Cr√©e le r√©seau Docker si inexistant (idempotent).

**Pourquoi**

* Isolation r√©seau pour backend + DB.

---

## 12) Gestion du conteneur MySQL

Bloc complet qui v√©rifie :

* Si `mysql-prod` existe ‚Üí on d√©marre.
* Si `mysql-sentinel` existe ‚Üí on le **renomme** en `mysql-prod`.
* Sinon ‚Üí on cr√©e un nouveau conteneur `mysql-prod`.

**Pourquoi**

* On veut **un seul** conteneur MySQL canonique (`mysql-prod`).
* √âvite d‚Äôavoir deux bases concurrentes.
* Volume persistant (`mysql-prod-data`) garde les donn√©es.

**Probl√®me r√©solu**

* Avant on avait un `mysql-sentinel` qui tra√Ænait ‚Üí confusions sur quelle DB √©tait utilis√©e.

---

## 13) Attente de MySQL

```bash
for i in $(seq 1 60); do
  if docker exec mysql-prod sh -lc "mysqladmin ping ‚Ä¶"; then
    break
  fi
  sleep 2
done
```

**Ce que √ßa fait**

* Attend que MySQL soit op√©rationnel (max \~120s).

**Pourquoi**

* Sans √ßa, l‚ÄôAPI d√©marre trop t√¥t ‚Üí migrations Prisma √©chouent.

---

## 14) Construction de `DATABASE_URL`

```bash
RUNTIME_DATABASE_URL="mysql://$MYSQL_USER:$MYSQL_PASSWORD@mysql-prod:3306/$MYSQL_DATABASE"
```

**Ce que √ßa fait**

* Construit l‚ÄôURL de connexion pour Prisma.

**Pourquoi**

* Dynamique, calcul√©e depuis secrets ‚Üí pas de fuite dans le d√©p√¥t.

---

## 15) Remplacement du conteneur backend

```bash
docker stop "$APP"
docker rm "$APP"
docker run -d ‚Ä¶ -e DATABASE_URL="$RUNTIME_DATABASE_URL" "$IMAGE"
```

**Ce que √ßa fait**

* Stoppe et supprime l‚Äôancien conteneur backend.
* Lance le nouveau avec la bonne image + env vars.

**Pourquoi**

* Assure qu‚Äôon tourne toujours sur une image propre.
* Secrets inject√©s au runtime ‚Üí image reste g√©n√©rique.

---

## 16) Healthcheck API

```bash
for i in $(seq 1 60); do
  if curl -fsS "http://localhost:${EXTERNAL_PORT}/health"; then
    exit 0
  fi
  sleep 2
done

exit 1
```

**Ce que √ßa fait**

* V√©rifie que `/health` r√©pond correctement sur le port expos√©.

**Pourquoi**

* Confirme que l‚ÄôAPI est r√©ellement fonctionnelle avant de valider le job.

---

## D√©cisions cl√©s & bonnes pratiques

* **Dockerfile multi-stage** : build (Prisma + compilation NestJS) ‚Üí runtime (ex√©cution).
* **OpenSSL** : ajout√© dans les deux √©tapes pour Prisma.
* **Seed en prod** : on lance mais non bloquant (`|| true`) pour √©viter un crash.
* **Nom unique MySQL** : toujours `mysql-prod` pour √©viter des doublons.
* **Secrets uniquement via GitHub Secrets** : rien en clair dans le d√©p√¥t.
* **Tags d‚Äôimage** : usage de `sha-<commit>` recommand√© pour d√©ploiements d√©terministes.

---

## Commandes de debug c√¥t√© serveur

```bash
# Conteneurs actifs
docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}'

# Logs
docker logs --tail=200 sentinel-back
docker logs --tail=200 mysql-prod

# Test API
curl -i http://localhost:3001/health

# V√©rifier contenu DB
docker exec -it mysql-prod mysql -u$MYSQL_USER -p$MYSQL_PASSWORD $MYSQL_DATABASE -e "SHOW TABLES;"

# V√©rifier DATABASE_URL dans le conteneur
docker exec -it sentinel-back printenv DATABASE_URL
```

# ğŸ“‘ 2.0 â€” Concurrence (`concurrency`)

Dans GitHub Actions, le bloc `concurrency` sert Ã  **Ã©viter les exÃ©cutions parallÃ¨les conflictuelles** dâ€™un mÃªme workflow (ou dâ€™un sous-ensemble), et Ã  **dÃ©finir quoi faire** si un nouveau run dÃ©marre alors quâ€™un ancien est encore en cours.

Configuration utilisÃ©e :

```yaml
concurrency:
  group: deploy-sentinel-monitoring-${{ github.ref }}
  cancel-in-progress: true
```

---

## ğŸ¯ Objectif

* EmpÃªcher **plusieurs dÃ©ploiements simultanÃ©s** de la mÃªme cible (ici, ton serveur Sentinel).
* Ã‰viter les **Ã©tats incohÃ©rents** provoquÃ©s par deux `rsync`/`docker compose` qui se marchent dessus.
* Assurer que **la derniÃ¨re modification poussÃ©e** est celle qui sera dÃ©ployÃ©e (et pas une ancienne en retard).

---

## ğŸ§© DÃ©tail des options

### `group: deploy-sentinel-monitoring-${{ github.ref }}`

* DÃ©finit le **groupe de concurrence**.
* Tous les runs qui partagent **la mÃªme valeur de `group`** sont considÃ©rÃ©s comme concurrents.
* Ici on concatÃ¨ne un prÃ©fixe lisible (`deploy-sentinel-monitoring-`) avec **la ref Git** (`${{ github.ref }}`), par ex. :

    * `refs/heads/main` pour `main`
    * `refs/heads/feature/x` pour une branche de feature

**Effet :**

* Deux runs *sur la mÃªme branche* (donc mÃªme `github.ref`) **ne sâ€™exÃ©cuteront pas en parallÃ¨le**.
* Deux runs sur **des branches diffÃ©rentes** nâ€™entrent **pas** en concurrence (utile si tu veux tester sur une branche sans bloquer `main`).

> Variante courante :
>
> * `group: deploy-sentinel-monitoring-${{ github.ref_name }}` (nom court de branche)
> * `group: deploy-sentinel-monitoring-prod` (un seul groupe global si tu **ne veux jamais** de parallÃ©lisme, toutes branches confondues)

### `cancel-in-progress: true`

* Si un **nouveau run** est dÃ©clenchÃ© alors quâ€™un run du **mÃªme groupe** est **encore en cours** :

    * Le run **en cours est annulÃ©**
    * Le **nouveau run dÃ©marre** et devient la rÃ©fÃ©rence

**Pourquoi câ€™est bien pour un dÃ©ploiement ?**

* Tu Ã©vites de **dÃ©ployer une version obsolÃ¨te** si de nouveaux commits arrivent pendant un run.
* Tu garantis que **la derniÃ¨re version** (la plus Ã  jour) est finalement celle qui part en prod.

---

## ğŸ§  Quand est-ce indispensable ?

* **DÃ©ploiement sur une cible unique** (un serveur, une base, un bucketâ€¦)
  â†’ Tu **ne veux pas** deux jobs qui Ã©crivent en mÃªme temps.
* **Workflows longs** qui peuvent Ãªtre dÃ©clenchÃ©s souvent
  â†’ Tu Ã©vites les files dâ€™attente et tu **privilÃ©gies le dernier commit**.
* **Idempotence** souhaitÃ©e
  â†’ Tu peux relancer sans risque ; si un nouveau push arrive, lâ€™ancien run est tuÃ©.

---

## ğŸ”€ ModÃ¨les utiles (selon tes besoins)

* **Un seul dÃ©ploiement Ã  la fois, toutes branches confondues**

  ```yaml
  concurrency:
    group: deploy-sentinel-monitoring
    cancel-in-progress: true
  ```

* **Concurrence par environnement** (ex: `prod`, `staging`)

  ```yaml
  concurrency:
    group: deploy-sentinel-${{ inputs.environment }}
    cancel-in-progress: true
  ```

* **Concurrence par serveur** si tu dÃ©ploies plusieurs sentinels

  ```yaml
  concurrency:
    group: deploy-sentinel-${{ vars.SSH_HOST }}
    cancel-in-progress: true
  ```

---

## âš ï¸ Points dâ€™attention

* `cancel-in-progress: true` **tue lâ€™ancien run** : pratique pour â€œtoujours dÃ©ployer le dernierâ€, mais si tu avais des **Ã©tapes longues non idempotentes** (ex. migration DB risquÃ©e), pense Ã  les protÃ©ger (migrations transactionnelles, verrous applicatifs, backups).
* Si tu fais des dÃ©ploiements **multi-environnements** dans le mÃªme workflow, utilise un `group` **diffÃ©rent par environnement** pour ne pas bloquer (`prod`, `staging`, etc.).

---

## âœ… TL;DR

* **`group`** = qui entre en concurrence (ici : par branche grÃ¢ce Ã  `github.ref`).
* **`cancel-in-progress: true`** = on annule lâ€™ancien run pour dÃ©ployer **la derniÃ¨re version**.
* Parfait pour tes **dÃ©ploiements Sentinel** : **pas de conflits**, **pas de versions obsolÃ¨tes**, **toujours la plus rÃ©cente** en production.

# 📑 2.0 — Concurrence (`concurrency`)

Dans GitHub Actions, le bloc `concurrency` sert à **éviter les exécutions parallèles conflictuelles** d’un même workflow (ou d’un sous-ensemble), et à **définir quoi faire** si un nouveau run démarre alors qu’un ancien est encore en cours.

Configuration utilisée :

```yaml
concurrency:
  group: deploy-sentinel-monitoring-${{ github.ref }}
  cancel-in-progress: true
```

---

## 🎯 Objectif

* Empêcher **plusieurs déploiements simultanés** de la même cible (ici, ton serveur Sentinel).
* Éviter les **états incohérents** provoqués par deux `rsync`/`docker compose` qui se marchent dessus.
* Assurer que **la dernière modification poussée** est celle qui sera déployée (et pas une ancienne en retard).

---

## 🧩 Détail des options

### `group: deploy-sentinel-monitoring-${{ github.ref }}`

* Définit le **groupe de concurrence**.
* Tous les runs qui partagent **la même valeur de `group`** sont considérés comme concurrents.
* Ici on concatène un préfixe lisible (`deploy-sentinel-monitoring-`) avec **la ref Git** (`${{ github.ref }}`), par ex. :

    * `refs/heads/main` pour `main`
    * `refs/heads/feature/x` pour une branche de feature

**Effet :**

* Deux runs *sur la même branche* (donc même `github.ref`) **ne s’exécuteront pas en parallèle**.
* Deux runs sur **des branches différentes** n’entrent **pas** en concurrence (utile si tu veux tester sur une branche sans bloquer `main`).

> Variante courante :
>
> * `group: deploy-sentinel-monitoring-${{ github.ref_name }}` (nom court de branche)
> * `group: deploy-sentinel-monitoring-prod` (un seul groupe global si tu **ne veux jamais** de parallélisme, toutes branches confondues)

### `cancel-in-progress: true`

* Si un **nouveau run** est déclenché alors qu’un run du **même groupe** est **encore en cours** :

    * Le run **en cours est annulé**
    * Le **nouveau run démarre** et devient la référence

**Pourquoi c’est bien pour un déploiement ?**

* Tu évites de **déployer une version obsolète** si de nouveaux commits arrivent pendant un run.
* Tu garantis que **la dernière version** (la plus à jour) est finalement celle qui part en prod.

---

## 🧠 Quand est-ce indispensable ?

* **Déploiement sur une cible unique** (un serveur, une base, un bucket…)
  → Tu **ne veux pas** deux jobs qui écrivent en même temps.
* **Workflows longs** qui peuvent être déclenchés souvent
  → Tu évites les files d’attente et tu **privilégies le dernier commit**.
* **Idempotence** souhaitée
  → Tu peux relancer sans risque ; si un nouveau push arrive, l’ancien run est tué.

---

## 🔀 Modèles utiles (selon tes besoins)

* **Un seul déploiement à la fois, toutes branches confondues**

  ```yaml
  concurrency:
    group: deploy-sentinel-monitoring
    cancel-in-progress: true
  ```

* **Concurrence par environnement** (ex: `prod`, `staging`)

  ```yaml
  concurrency:
    group: deploy-sentinel-${{ inputs.environment }}
    cancel-in-progress: true
  ```

* **Concurrence par serveur** si tu déploies plusieurs sentinels

  ```yaml
  concurrency:
    group: deploy-sentinel-${{ vars.SSH_HOST }}
    cancel-in-progress: true
  ```

---

## ⚠️ Points d’attention

* `cancel-in-progress: true` **tue l’ancien run** : pratique pour “toujours déployer le dernier”, mais si tu avais des **étapes longues non idempotentes** (ex. migration DB risquée), pense à les protéger (migrations transactionnelles, verrous applicatifs, backups).
* Si tu fais des déploiements **multi-environnements** dans le même workflow, utilise un `group` **différent par environnement** pour ne pas bloquer (`prod`, `staging`, etc.).

---

## ✅ TL;DR

* **`group`** = qui entre en concurrence (ici : par branche grâce à `github.ref`).
* **`cancel-in-progress: true`** = on annule l’ancien run pour déployer **la dernière version**.
* Parfait pour tes **déploiements Sentinel** : **pas de conflits**, **pas de versions obsolètes**, **toujours la plus récente** en production.

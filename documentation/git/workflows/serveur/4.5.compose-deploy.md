# 📑 4.5 — Compose deploy

Cette étape exécute le **déploiement réel** de la stack depuis le serveur (dans `/root/sentinel`).
Elle **valide** la configuration, **met à jour** les images, **remplace** proprement l’ancienne stack et **relance** les services.

---

## 🔹 Le step dans le workflow

```yaml
# 🚀 Déploiement depuis /root/sentinel
- name: Compose deploy
  uses: appleboy/ssh-action@v1.0.0
  with:
    host: ${{ vars.SSH_HOST }}
    username: ${{ vars.SSH_USER }}
    password: ${{ secrets.SSH_PASSWORD }}
    port: 22
    script: |
      set -euo pipefail
      cd /root/sentinel

      echo "==> Validation de la config"
      docker compose config >/dev/null

      echo "==> Pull des images (si :latest)"
      docker compose pull || true

      echo "==> Down ancienne stack"
      docker compose down --remove-orphans || true

      echo "==> Up nouvelle stack"
      docker compose up -d

      echo "==> Etat"
      docker compose ps
```

---

## 🔍 Décomposition ligne par ligne

### Sécurisation & contexte

* `set -euo pipefail`

    * `-e` : stoppe à la première erreur
    * `-u` : interdit d’utiliser une variable non définie
    * `pipefail` : toute erreur dans un pipe fait échouer la commande
      👉 Évite les déploiements “à moitié”.

* `cd /root/sentinel`
  On se place **dans le dossier qui contient** `docker-compose.yml`.
  👉 Sans ça, `docker compose` ne trouverait pas la stack.

---

### 1) Validation statique

```bash
docker compose config >/dev/null
```

* **Fusionne** tous les fichiers Compose, résout les variables, vérifie la **syntaxe**.
* Échoue immédiatement en cas d’erreur (clé inconnue, indentation, var manquante…).
* Redirigé vers `/dev/null` car on veut juste le **code de retour**.
  👉 C’est le **pare-feu** qui empêche de déployer une config cassée.

---

### 2) Mise à jour des images

```bash
docker compose pull || true
```

* Télécharge les **nouvelles versions** des images référencées (utile si tu utilises `:latest`).
* `|| true` : ne bloque pas le déploiement si un pull échoue (ex. pas de réseau, tag déjà à jour).
  👉 Bonne pratique si tu veux rester à jour **sans** rebuilder.

> 💡 Conseil : en prod, préfère **des tags versionnés** (`grafana:12.1.1`) plutôt que `latest`, pour des déploiements **reproductibles**.

---

### 3) Arrêt propre & nettoyage

```bash
docker compose down --remove-orphans || true
```

* **Stoppe** et **supprime** les conteneurs de la stack actuelle.
* `--remove-orphans` nettoie les services **qui n’existent plus** dans le compose (évite les “fantômes”).
* Ne supprime **pas** les volumes nommés par défaut → **données persistantes** conservées (Grafana DB, Loki WAL…).
* `|| true` : ne casse pas le job si rien n’était lancé.
  👉 Repart sur une base **propre** avant de (re)monter.

> 🔎 Remarque : `down` supprime aussi les **réseaux** de la stack ; ils seront recréés au `up`.

---

### 4) Relance (déploiement)

```bash
docker compose up -d
```

* (Re)crée et lance les services **en détaché**.
* Recrée **uniquement** ce qui a changé (image, env, volumes, mounts, cmd…).
* Respecte `restart: unless-stopped` si défini.
  👉 C’est l’étape qui **applique** le nouvel état.

> 🧠 Astuce : `docker compose up -d --force-recreate` pour forcer la recréation,
> ou `--pull always` (Compose v2.23+) pour tirer systématiquement les images.

---

### 5) État post-déploiement

```bash
docker compose ps
```

* Affiche un **résumé** : noms, ports exposés, statut, politique de redémarrage.
  👉 Vérif visuelle rapide que tout est **UP**.

---

## 🧠 Idempotence & ce que **ça ne fait pas**

* **Idempotent** : relancer cette étape remet la stack **dans l’état décrit** par ton repo.
* **Ne supprime pas** les volumes nommés → les données (ex. Grafana) **restent**.
* **Ne build pas** d’images locales (on n’utilise pas `build:` ici). Si tu en ajoutes, il faudra `docker compose build`.

---

## 🧪 Diagnostic rapide (si souci)

* Voir les logs d’un service :

  ```bash
  docker compose logs -n 200 grafana
  docker compose logs -f loki
  ```
* Voir la config effective (très utile !) :

  ```bash
  docker compose config
  ```
* Vérifier volumes & réseaux :

  ```bash
  docker volume ls
  docker network ls
  ```
* Tester la santé applicative :

  ```bash
  curl -sf http://localhost:9090/-/ready && echo OK
  curl -sf http://localhost:3100/ready && echo OK
  curl -sf http://localhost:3000/login && echo OK
  ```

---

## ⚠️ Pièges fréquents & bonnes pratiques

* **Orphans non retirés** → garde `--remove-orphans` pour nettoyer les services retirés du compose.
* **Tags `latest`** → imprévisibles. Préfère des **versions pinées** en prod.
* **Provisioning Grafana** → si tu changes les YAML mais Grafana “garde l’ancien” (DB), pense aux options `delete*` dans tes fichiers de provisioning.
* **Secrets/env** → injecte via **Secrets GitHub** (pas en clair dans le compose).
* **Ordre de dépendances** → `depends_on` aide à l’ordre, mais **n’attend pas** que le service soit “ready”. Pour ça, utilise **healthchecks** et des retries côté client.

---

## ✅ TL;DR

* **`config`** : stoppe net si la config Compose est invalide.
* **`pull`** : met à jour les images (utile pour `latest`).
* **`down --remove-orphans`** : nettoie proprement l’ancienne stack.
* **`up -d`** : (re)lance la nouvelle.
* **`ps`** : contrôle final.

C’est le **cœur du déploiement** : simple, sûr, et **rejouable** à l’infini.

# ğŸ“˜ 7.0 â€“ Bonnes pratiques

---

## ğŸ” 1. Variables sensibles â†’ GitHub Secrets

**Pourquoi ?**

* Ne jamais stocker de mot de passe, clÃ© SSH ou token SMTP dans le repo â†’ risque Ã©norme de fuite.
* Les **GitHub Secrets** sont chiffrÃ©s et injectÃ©s uniquement au moment de lâ€™exÃ©cution dans la VM GitHub Actions.

**Exemples typiques** :

* `SSH_PASSWORD` ou `SSH_PRIVATE_KEY` â†’ pour se connecter au serveur.
* `GF_SMTP_PASSWORD` â†’ pour Grafana Alerting.
* `GF_SECURITY_ADMIN_PASSWORD` â†’ mot de passe admin Grafana.

**Syntaxe dâ€™utilisation** :

```yaml
with:
  password: ${{ secrets.SSH_PASSWORD }}
```

ou

```yaml
env:
  GF_SMTP_PASSWORD: ${{ secrets.GF_SMTP_PASSWORD }}
```

ğŸ‘‰ **Important** : utiliser des secrets pour *tous* les credentials (mÃªme de test), pour Ã©viter les mauvaises habitudes.

---

## ğŸ’¾ 2. Volumes nommÃ©s pour la persistance

**Pourquoi ?**

* Les conteneurs Docker sont **Ã©phÃ©mÃ¨res**. Si tu fais `docker compose down -v`, toutes les donnÃ©es disparaissent.
* Les **volumes nommÃ©s** permettent de conserver les donnÃ©es (DB Grafana, sÃ©ries Prometheus, logs Loki) mÃªme aprÃ¨s redÃ©ploiement.

**Exemple dans `docker-compose.yml`** :

```yaml
volumes:
  grafana-data:
  prometheus-data:
  loki-data:

services:
  grafana:
    volumes:
      - grafana-data:/var/lib/grafana
  prometheus:
    volumes:
      - prometheus-data:/prometheus
  loki:
    volumes:
      - loki-data:/loki
```

ğŸ‘‰ Cela garantit que tes dashboards crÃ©Ã©s Ã  la main ou tes mÃ©triques historiques **ne disparaissent pas aprÃ¨s un `up -d`**.

---

## ğŸ“Š 3. Provisioning Grafana â†’ `delete*` pour forcer la synchro

**ProblÃ¨me classique** :

* Tu modifies un dashboard dans Git â†’ mais Grafana garde une **ancienne version en base SQLite**.
* RÃ©sultat : la modification nâ€™est pas appliquÃ©e, mÃªme si le fichier a changÃ©.

**Solution** :

* Utiliser les options `deleteDatasources` et `deleteDashboards` dans les fichiers de provisioning Grafana.
* Cela force Grafana Ã  **supprimer les objets existants et recharger la version Git**.

**Exemple (`datasource.yml`)** :

```yaml
apiVersion: 1

deleteDatasources:
  - name: Prometheus
  - name: Loki

datasources:
  - name: Prometheus
    type: prometheus
    url: http://prometheus:9090
    access: proxy
    isDefault: true
  - name: Loki
    type: loki
    url: http://loki:3100
    access: proxy
```

ğŸ‘‰ Ainsi, ton repo Git reste **la seule source de vÃ©ritÃ©** (et non pas la DB Grafana).

---

## ğŸ”„ 4. Idempotence â†’ relancer = mÃªme Ã©tat

**IdÃ©e clÃ©** :

* Un workflow bien conÃ§u doit Ãªtre **idempotent**.
* Peu importe combien de fois tu le lances â†’ tu dois toujours retomber sur **le mÃªme Ã©tat attendu**.

**Comment on y arrive ?**

* `rsync --delete` â†’ supprime les fichiers obsolÃ¨tes pour Ã©viter les incohÃ©rences.
* `docker compose down --remove-orphans` â†’ nettoie les vieux conteneurs qui ne sont plus dÃ©finis dans `compose.yml`.
* Bootstrap (`apt install`, `docker install`) â†’ toujours rejouable, mÃªme si dÃ©jÃ  installÃ© (`if ! command -v docker ...`).
* Health checks â†’ valident que les services sont bien up aprÃ¨s dÃ©ploiement.

ğŸ‘‰ RÃ©sultat : tu peux lancer le workflow aprÃ¨s **chaque commit, chaque rollback ou chaque panne serveur** â†’ tu repars toujours dâ€™une base saine.

---

## ğŸ§­ RÃ©sumÃ© des bonnes pratiques

1. **SÃ©curitÃ©** â†’ toujours isoler les credentials dans GitHub Secrets.
2. **Persistance** â†’ utiliser des volumes nommÃ©s pour ne pas perdre Grafana, Prometheus et Loki.
3. **Synchronisation fiable** â†’ activer `delete*` dans le provisioning Grafana.
4. **Idempotence** â†’ le workflow doit Ãªtre rejouable Ã  lâ€™infini avec le mÃªme rÃ©sultat.

---

âš¡ Avec ces rÃ¨gles appliquÃ©es, ton workflow Sentinel devient :

* **SÃ©curisÃ©** (pas de fuite sensible),
* **Fiable** (pas dâ€™incohÃ©rence serveur vs repo),
* **Stable** (rejouable sans casse),
* **Maintenable** (toute lâ€™Ã©quipe peut lâ€™utiliser sans crainte).

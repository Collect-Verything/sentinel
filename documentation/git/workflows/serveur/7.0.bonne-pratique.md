# 📘 7.0 – Bonnes pratiques

---

## 🔐 1. Variables sensibles → GitHub Secrets

**Pourquoi ?**

* Ne jamais stocker de mot de passe, clé SSH ou token SMTP dans le repo → risque énorme de fuite.
* Les **GitHub Secrets** sont chiffrés et injectés uniquement au moment de l’exécution dans la VM GitHub Actions.

**Exemples typiques** :

* `SSH_PASSWORD` ou `SSH_PRIVATE_KEY` → pour se connecter au serveur.
* `GF_SMTP_PASSWORD` → pour Grafana Alerting.
* `GF_SECURITY_ADMIN_PASSWORD` → mot de passe admin Grafana.

**Syntaxe d’utilisation** :

```yaml
with:
  password: ${{ secrets.SSH_PASSWORD }}
```

ou

```yaml
env:
  GF_SMTP_PASSWORD: ${{ secrets.GF_SMTP_PASSWORD }}
```

👉 **Important** : utiliser des secrets pour *tous* les credentials (même de test), pour éviter les mauvaises habitudes.

---

## 💾 2. Volumes nommés pour la persistance

**Pourquoi ?**

* Les conteneurs Docker sont **éphémères**. Si tu fais `docker compose down -v`, toutes les données disparaissent.
* Les **volumes nommés** permettent de conserver les données (DB Grafana, séries Prometheus, logs Loki) même après redéploiement.

**Exemple dans `docker-compose.yml`** :

```yaml
volumes:
  grafana-data:
  prometheus-data:
  loki-data:

services:
  grafana:
    volumes:
      - grafana-data:/var/lib/grafana
  prometheus:
    volumes:
      - prometheus-data:/prometheus
  loki:
    volumes:
      - loki-data:/loki
```

👉 Cela garantit que tes dashboards créés à la main ou tes métriques historiques **ne disparaissent pas après un `up -d`**.

---

## 📊 3. Provisioning Grafana → `delete*` pour forcer la synchro

**Problème classique** :

* Tu modifies un dashboard dans Git → mais Grafana garde une **ancienne version en base SQLite**.
* Résultat : la modification n’est pas appliquée, même si le fichier a changé.

**Solution** :

* Utiliser les options `deleteDatasources` et `deleteDashboards` dans les fichiers de provisioning Grafana.
* Cela force Grafana à **supprimer les objets existants et recharger la version Git**.

**Exemple (`datasource.yml`)** :

```yaml
apiVersion: 1

deleteDatasources:
  - name: Prometheus
  - name: Loki

datasources:
  - name: Prometheus
    type: prometheus
    url: http://prometheus:9090
    access: proxy
    isDefault: true
  - name: Loki
    type: loki
    url: http://loki:3100
    access: proxy
```

👉 Ainsi, ton repo Git reste **la seule source de vérité** (et non pas la DB Grafana).

---

## 🔄 4. Idempotence → relancer = même état

**Idée clé** :

* Un workflow bien conçu doit être **idempotent**.
* Peu importe combien de fois tu le lances → tu dois toujours retomber sur **le même état attendu**.

**Comment on y arrive ?**

* `rsync --delete` → supprime les fichiers obsolètes pour éviter les incohérences.
* `docker compose down --remove-orphans` → nettoie les vieux conteneurs qui ne sont plus définis dans `compose.yml`.
* Bootstrap (`apt install`, `docker install`) → toujours rejouable, même si déjà installé (`if ! command -v docker ...`).
* Health checks → valident que les services sont bien up après déploiement.

👉 Résultat : tu peux lancer le workflow après **chaque commit, chaque rollback ou chaque panne serveur** → tu repars toujours d’une base saine.

---

## 🧭 Résumé des bonnes pratiques

1. **Sécurité** → toujours isoler les credentials dans GitHub Secrets.
2. **Persistance** → utiliser des volumes nommés pour ne pas perdre Grafana, Prometheus et Loki.
3. **Synchronisation fiable** → activer `delete*` dans le provisioning Grafana.
4. **Idempotence** → le workflow doit être rejouable à l’infini avec le même résultat.

---

⚡ Avec ces règles appliquées, ton workflow Sentinel devient :

* **Sécurisé** (pas de fuite sensible),
* **Fiable** (pas d’incohérence serveur vs repo),
* **Stable** (rejouable sans casse),
* **Maintenable** (toute l’équipe peut l’utiliser sans crainte).
